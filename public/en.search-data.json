{"/docs/":{"data":{"":"","aspnet-core-posts#ASP.NET Core Posts":"\nMocking Request Handling by HTTP Client How to mock HTTP request handling by a HTTP Client while writing unit tests\nPost Coming Soon Something new will come soon.\nPost Coming Soon Something new will come soon."},"title":"Docs"},"/docs/asp-dotnet-core/":{"data":{"":"","posts-in-this-area#Posts in this area":"\nMocking Request Handling by HTTP Client How to mock a HTTP requests by a HTTP Client while writing unit tests\nPost Coming Soon Something new will come soon.\nPost Coming Soon Something new will come soon."},"title":"ASP.NET Core"},"/docs/asp-dotnet-core/controllers/":{"data":{"":"In ASP.NET Core, a controller is a class that handles incoming HTTP requests, processes them (often with the help of a model or service), and returns a response—usually a View, JSON, or a status code.\nControllers are a core part of the MVC pattern (Model-View-Controller) and are typically located in the Controllers folder of your project.\nA controller:\nInherits from Controller or ControllerBase Contains action methods—each mapped to an HTTP request like GET, POST, PUT, DELETE Uses attributes like [HttpGet], [HttpPost], [Route] to define routing behavior using Microsoft.AspNetCore.Mvc; using System.Collections.Generic; namespace MyApp.Controllers { [ApiController] [Route(\"api/[controller]\")] public class ProductController : ControllerBase { // Mock data private static List\u003cstring\u003e products = new List\u003cstring\u003e { \"Laptop\", \"Mouse\", \"Keyboard\" }; // GET: api/product [HttpGet] public ActionResult\u003cList\u003cstring\u003e\u003e GetAll() { return products; } // GET: api/product/1 [HttpGet(\"{id}\")] public ActionResult\u003cstring\u003e GetById(int id) { if (id \u003c 0 || id \u003e= products.Count) return NotFound(\"Product not found\"); return products[id]; } // POST: api/product [HttpPost] public ActionResult AddProduct([FromBody] string product) { products.Add(product); return Ok(\"Product added\"); } } } "},"title":"Controllers"},"/docs/asp-dotnet-core/mockinghttpclient/":{"data":{"":"","#":"There would surely be scenarios in your application where you should use a HTTP Client to request for resources from another server. But how can you mock the behaviour of the default methods of the Http Client provided by the .NET Core Framework while writing unit tests? This post is meant to mock such HTTP request handling for unit testing.\nConsider the following code where a service named SocialMediaPostsService uses a HTTP Client to request json objects from Dummy JSON.\nSocialMediaPostsService.cspublic class SocialMediaPostsService(IHttpClientFactory httpClientFactory) : ISocialMediaPostsService { private const string BaseUrl = \"https://dummyjson.com\"; private readonly HttpClient _httpClient = httpClientFactory.CreateClient( Constants.DUMMY_JSON_CLIENT ); public async Task\u003cIEnumerable\u003cstring\u003e?\u003e GetAllTagsForPostAsync( int postId, CancellationToken cancellationToken ) { var response = await _httpClient.GetAsync($\"{BaseUrl}/posts\", cancellationToken); response.EnsureSuccessStatusCode(); var posts = await response.Content.ReadFromJsonAsync\u003cPostsResponse\u003e( ObjectSerializer.GetOptions, cancellationToken ); return posts!.Posts.FirstOrDefault(x =\u003e x.Id == postId)?.Tags; } public async Task\u003cPost\u003e AddPostAsync( Post post, CancellationToken cancellationToken ) { var response = await _httpClient.PostAsJsonAsync( $\"{BaseUrl}/posts/add\", post, ObjectSerializer.GetOptions, cancellationToken ); response.EnsureSuccessStatusCode(); return await response.Content.ReadFromJsonAsync\u003cPost\u003e( ObjectSerializer.GetOptions, cancellationToken ) ?? throw new InvalidOperationException(\"Failed to deserialize the post.\"); } } Note\nUsing IHttpClientFactory ensures efficient connection management and allows pre-configured named clients for consistent setup and reuse.\nShown below is the ISocialMediaPostsService interface used for dependency injection.\nISocialMediaPostsService.cspublic interface ISocialMediaPostsService { Task\u003cIEnumerable\u003cstring\u003e?\u003e GetAllTagsForPostAsync( int postId, CancellationToken cancellationToken ); Task\u003cPost\u003e AddPostAsync( Post post, CancellationToken cancellationToken ); } To be able to understand how the client can be mocked, it is essential to understand how the client handles the HTTP request message.\nIn Brief HttpClient inherits from HttpMessageInvoker The HttpClient class is built on top of HttpMessageInvoker, which is responsible for forwarding HTTP requests.\nIf you carefully look at the source code for HttpClient, you will notice that the class inherits from HttpMessageInvoker. Our Http Client’s GetAsync method internally invokes a base method in HttpMessageInvoker namely:\nHttpMessageInvoker.cspublic virtual Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) HttpMessageInvoker holds a reference to HttpMessageHandler When an HTTP request is made, HttpMessageInvoker uses the internal HttpMessageHandler provided to handle the HTTP request.\nThe request is passed to HttpMessageHandler The handler processes the request. This is the main point where the actual HTTP logic is handled. The following is the core method for handling.\nHttpMessageHandler.csprotected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken) { throw new NotSupportedException(SR.Format(SR.net_http_missing_sync_implementation, GetType(), nameof(HttpMessageHandler), nameof(Send))); } Custom handlers can override this behavior The HttpMessageHandler class provides the following abstract method to be overriden by an extending class to implement a custom handling of HttpRequestMessage.\nHttpMessageHandler.csprotected internal abstract Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken); By extending HttpMessageHandler, we can intercept requests and return controlled responses, which is how mocking works in tests.\nOur MockHttpMessageHandler would look like this MockHttpMessageHandler.cspublic class MockHttpMessageHandler : HttpMessageHandler { protected override Task\u003cHttpResponseMessage\u003e SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { return Task.FromResult(MockSendAsync(request, cancellationToken)); } public virtual HttpResponseMessage MockSend( HttpRequestMessage request, CancellationToken cancellationToken ) { throw new NotImplementedException(); } } In the above HTTP mock handler we can create our own method MockSend to be overwritten when we like to write a test, but for the moment we just throw a NotImplementedException. We can then override the abstract method provided by HttpMessageHandler to return the result of our own method MockSend. This is how we can make sure than when the HttpMessageHandler's SendAsyncmethod is invoked by the framework, our method MockSend is invoked internally.\nMockHttpMessageHandlerTestBase class for reusable testing For the ease of writing tests for classes that uses a HttpClient, we can create a resuable class to handle everything related to our HTTP mock handler, like making our handler return a specific object and a staus code, ensure that the mock handler had received a HTTP request message with a particular Ùri,HttpMethod and Content. The test class uses the follwoing library:\nxUnit NSubstitue Shouldly AutoBogus MockHttpMessageHandlerTestBasecspublic class MockHttpMessageHandlerTestBase { protected MockHttpMessageHandlerTestBase() { var httpClient = new HttpClient(HttpMessageHandlerMock) { BaseAddress = new Uri(\"http://localhost:5000\") }; HttpClientFactory.CreateClient(Arg.Any\u003cstring\u003e()).Returns(httpClient); } private MockHttpMessageHandler HttpMessageHandlerMock { get; } = Substitute.ForPartsOf\u003cMockHttpMessageHandler\u003e(); protected IHttpClientFactory HttpClientFactory { get; } = Substitute.For\u003cIHttpClientFactory\u003e(); /// \u003csummary\u003e /// Verifies that the mocked HTTP message handler processes a request with the specified HTTP method /// and a request URI containing the given string. /// \u003c/summary\u003e /// \u003cparam name=\"httpMethod\"\u003eThe HTTP method (e.g., GET, POST) to validate against the request.\u003c/param\u003e /// \u003cparam name=\"requestUri\"\u003eThe string that should be contained in the request URI.\u003c/param\u003e protected void HttpMockHandlerShouldHandleFor(HttpMethod httpMethod, string requestUri) { HttpMockHandlerDoes(message =\u003e { message.Method.ShouldBe(httpMethod); message.RequestUri!.AbsoluteUri.ShouldContain(requestUri); }); } /// \u003csummary\u003e /// Configures the mocked HTTP message handler to return a response with the specified content and status code /// when any HTTP request is sent. /// \u003c/summary\u003e /// \u003ctypeparam name=\"TResponse\"\u003eThe type of the response content to be serialized as JSON.\u003c/typeparam\u003e /// \u003cparam name=\"response\"\u003eThe response object to be serialized and returned in the HTTP response body.\u003c/param\u003e /// \u003cparam name=\"statusCode\"\u003eThe HTTP status code to be set in the response.\u003c/param\u003e protected void HttpMockHandlerReturns\u003cTResponse\u003e(TResponse response, HttpStatusCode statusCode) { HttpMessageHandlerMock .MockSend(Arg.Any\u003cHttpRequestMessage\u003e(), Arg.Any\u003cCancellationToken\u003e()) .Returns(x =\u003e new HttpResponseMessage(statusCode) { Content = JsonContent.Create(response) }); } /// \u003csummary\u003e /// Verifies that the mocked HTTP message handler receives a request with a JSON body /// matching the specified request object. /// \u003c/summary\u003e /// \u003ctypeparam name=\"TRequest\"\u003eThe type of the request object expected in the HTTP request body.\u003c/typeparam\u003e /// \u003cparam name=\"requestObject\"\u003eThe expected request object to compare against the deserialized request body.\u003c/param\u003e protected void HttpMockHandlerShouldReceiveObject\u003cTRequest\u003e(TRequest requestObject) { HttpMockHandlerDoes(message =\u003e { Debug.Assert(message.Content != null); var content = message.Content.ReadAsStringAsync().Result; var receivedObject = JsonSerializer.Deserialize\u003cTRequest\u003e(content); receivedObject.ShouldBe(requestObject); }); } private void HttpMockHandlerDoes(Action\u003cHttpRequestMessage\u003e callbackAction) { HttpMessageHandlerMock .When(x =\u003e x.MockSend(Arg.Any\u003cHttpRequestMessage\u003e(), Arg.Any\u003cCancellationToken\u003e())) .Do(x =\u003e callbackAction(x.Arg\u003cHttpRequestMessage\u003e())); } } Note\nNote how we create a HttpClient with our custom handler HttpMessageHandlerMock as the request message handler and carefully mock the CreateClient of the IHttpClientFactory to return the HttpClient.\nWarning\nThe above MockHttpMessageHandlerTestBase can be used as test base class if you use the interface ÌHttpClientFactory to create the HttpClient. Otherwise you need to modify the base class.\nWriting unit tests with MockHttpMessageHandlerTestBase SocialMediaPostsServiceTests.cspublic class SocialMediaPostsServiceTests : MockHttpMessageHandlerTestBase { private readonly ISocialMediaPostsService _socialMediaPostsServiceMock; public SocialMediaPostsServiceTests() { _socialMediaPostsServiceMock = new SocialMediaPostsService(HttpClientFactory); } [Theory] [InlineData(1)] [InlineData(2)] public async Task GetAllTagsForPostTestAsync(int postId) { var posts = GetAllPosts(); HttpMockHandlerReturns(posts, HttpStatusCode.OK); HttpMockHandlerShouldHandleFor(HttpMethod.Get, \"dummyjson.com/posts\"); var tags = await _socialMediaPostsServiceMock.GetAllTagsForPostAsync( postId, CancellationToken.None ); tags.ShouldBeEquivalentTo(posts.Posts.Find(x =\u003e x.Id == postId)?.Tags); } [Fact] public async Task AddPostTestAsync() { var postToSend = new AutoFaker\u003cPost\u003e().UseSeed(42).Generate(); var postReceived = new AutoFaker\u003cPost\u003e().UseSeed(42).Generate(); HttpMockHandlerReturns(postReceived, HttpStatusCode.OK); HttpMockHandlerShouldHandleFor(HttpMethod.Post, \"dummyjson.com/posts/add\"); var post = await _socialMediaPostsServiceMock.AddPostAsync( postToSend, CancellationToken.None ); post.ShouldNotBeNull(); post.ShouldBeEquivalentTo(postReceived); HttpMockHandlerShouldReceiveObject(postToSend); } private static PostsResponse GetAllPosts() { return new PostsResponse { Posts = [ new Post { Id = 1, Tags = new List\u003cstring\u003e { \"tag1\", \"tag2\", \"tag3\", \"tag4\" } }, new Post { Id = 2, Tags = new List\u003cstring\u003e { \"tag5\", \"tag6\" } } ], Total = 2, Skip = 0, Limit = 10 }; } } In this test, we inject a mock IHttpClientFactory into the service. The factory returns a HttpClient that uses our custom MockHttpMessageHandler. This lets us simulate HTTP responses and verify requests without making real network calls. The service uses this client just like it would in production, but everything is controlled in the test.\nYou can find the codes in the following GitHub repository.\nMocking-Request-Handling-by-HTTP-Client "},"title":"Mocking Request Handling by HTTP Client"},"/docs/design-patterns/":{"data":{"":"","posts-in-this-area#Posts in this area":"\nBuilder Pattern that constructs complex objects step by step while keeping creation logic separate and readable.\nPost Coming Soon Something new will come soon.\nPost Coming Soon Something new will come soon."},"title":"Design Patterns"},"/docs/design-patterns/builder/":{"data":{"":"Creating objects is one of the most common tasks in software development. In simple cases, a constructor is more than enough. However, as applications grow, object creation often becomes complex, error-prone, and hard to read.\nThis is where the Builder Pattern comes into play.\nThe Builder Pattern helps us construct complex objects step by step, while keeping the creation logic readable, maintainable, and flexible.","fluent-and-non-fluent-builder-patterns#Fluent and Non-Fluent Builder Patterns":"The Builder Pattern is often associated with fluent APIs and method chaining. However, fluent builders are only one variation of the pattern. In practice, there are two commonly used styles: non-fluent (classic) and fluent (modern) builders.\nBoth follow the same core idea—constructing a complex object step by step—but they differ in how the steps are expressed.","fluent-builder-modern-variation#Fluent Builder (Modern Variation)":"The fluent builder is a modern variation that improves readability by returning the builder instance (this) from each method. This allows multiple build steps to be chained together in a single expression.\nCharacteristics Builder methods return the builder itself Enables method chaining Emphasizes readability and developer experience Example Usage var report = new ReportBuilder() .WithHeader(\"Header\") .WithBody(\"Body\") .WithFooter(\"Footer\") .Build(); This style is especially popular in public APIs, SDKs, and configuration-heavy code, where clarity and ease of use are important.\nWhen to Use When an object has many optional parameters When API usability and readability matter When developers interact directly with the builder Implementation ","non-fluent-builder-classic-gof-style#Non-Fluent Builder (Classic GoF Style)":"The non-fluent builder is the original form described in the Gang of Four design patterns book. In this style, builder methods typically return void, and each method represents a distinct construction step.\nCharacteristics Builder methods return void Construction happens through explicit steps Order of method calls often matters Example Usage builder.BuildHeader(); builder.BuildBody(); builder.BuildFooter(); Here, each method modifies the internal state of the builder. Once all steps are completed, the final object is retrieved, usually through a separate method such as GetResult().\nWhen to Use When the construction process is complex When build steps must be enforced or ordered When the same construction process should create different representations A real-world example of this style is ASP.NET Core’s IApplicationBuilder, where the HTTP request pipeline is built step by step using UseXyz() methods. Implementation (Example 1) SocialMediaPostsServiceTests.cspublic class DeploymentPipeline { public bool ConfigurationValidated { get; set; } public bool ArtifactsBuilt { get; set; } public bool TestsExecuted { get; set; } public bool Deployed { get; set; } public bool Verified { get; set; } } SocialMediaPostsServiceTests.cspublic interface IDeploymentPipelineBuilder { void ValidateConfiguration(); void BuildArtifacts(); void RunTests(); void Deploy(); void Verify(); DeploymentPipeline GetResult(); } SocialMediaPostsServiceTests.cspublic class ProductionDeploymentBuilder : IDeploymentPipelineBuilder { private readonly DeploymentPipeline _pipeline = new(); public void ValidateConfiguration() { // Setting ConfigurationValidated to true for simulation purposes _pipeline.ConfigurationValidated = true; } public void BuildArtifacts() { if (!_pipeline.ConfigurationValidated) throw new InvalidOperationException(\"Configuration must be validated first.\"); _pipeline.ArtifactsBuilt = true; } public void RunTests() { if (!_pipeline.ArtifactsBuilt) throw new InvalidOperationException(\"Artifacts must be built before tests.\"); _pipeline.TestsExecuted = true; } public void Deploy() { if (!_pipeline.TestsExecuted) throw new InvalidOperationException(\"Tests must pass before deployment.\"); _pipeline.Deployed = true; } public void Verify() { if (!_pipeline.Deployed) throw new InvalidOperationException(\"Deployment must complete before verification.\"); _pipeline.Verified = true; } public DeploymentPipeline GetResult() { return _pipeline; } } SocialMediaPostsServiceTests.cspublic class DeploymentDirector(IDeploymentPipelineBuilder builder) { public DeploymentPipeline ConstructFullPipeline() { builder.ValidateConfiguration(); builder.BuildArtifacts(); builder.RunTests(); builder.Deploy(); builder.Verify(); return builder.GetResult(); } } Implementation (Example 2) ","the-intent-of-the-builder-pattern#The Intent of the Builder Pattern":" Important\n“Separate the construction of a complex object from its representation so that the same construction process can create different representations.”\nIn simpler terms:\nThe object is built incrementally Construction logic is separated from business logic The final object is only exposed once it is complete The Builder Pattern focuses on how an object is created, not just what it is. ","the-problem-complex-object-construction#The Problem: Complex Object Construction":"Consider an object with many optional parameters:\nvar user = new User( \"vicky\", \"vicky@example.com\", null, true, false, DateTime.Now ); At first glance, it’s not clear:\nWhat each parameter represents Which values are optional Whether the order is correct As more parameters are added, developers often introduce:\nConstructor overloading Optional parameters Long parameter lists All of these solutions work—but they don’t scale well.","when-should-you-use-the-builder-pattern#When Should You Use the Builder Pattern?":"The Builder Pattern is especially useful when:\nAn object has many optional properties Construction must happen in specific steps The same object can be built in different variations You want to avoid constructor telescoping You want more readable and expressive object creation "},"title":"Builder"},"/docs/design-patterns/factory/":{"data":{"":"Here comes the content of the factory pattern"},"title":"Factory"}}