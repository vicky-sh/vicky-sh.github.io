{"/docs/":{"data":{"":"","aspnet-core-posts#ASP.NET Core Posts":"\nMocking Request Handling by HTTP Client How to mock a HTTP requests by a HTTP Client while writing unit tests\nPost Coming Soon Something new will come soon.\nPost Coming Soon Something new will come soon."},"title":"Posts"},"/docs/asp.net-core/":{"data":{"":"","posts-in-this-area#Posts in this area":"\nMocking Request Handling by HTTP Client How to mock a HTTP requests by a HTTP Client while writing unit tests\nPost Coming Soon Something new will come soon.\nPost Coming Soon Something new will come soon."},"title":"ASP.NET Core"},"/docs/asp.net-core/controllers/":{"data":{"":"In ASP.NET Core, a controller is a class that handles incoming HTTP requests, processes them (often with the help of a model or service), and returns a response—usually a View, JSON, or a status code.\nControllers are a core part of the MVC pattern (Model-View-Controller) and are typically located in the Controllers folder of your project.\nA controller:\nInherits from Controller or ControllerBase Contains action methods—each mapped to an HTTP request like GET, POST, PUT, DELETE Uses attributes like [HttpGet], [HttpPost], [Route] to define routing behavior using Microsoft.AspNetCore.Mvc; using System.Collections.Generic; namespace MyApp.Controllers { [ApiController] [Route(\"api/[controller]\")] public class ProductController : ControllerBase { // Mock data private static List\u003cstring\u003e products = new List\u003cstring\u003e { \"Laptop\", \"Mouse\", \"Keyboard\" }; // GET: api/product [HttpGet] public ActionResult\u003cList\u003cstring\u003e\u003e GetAll() { return products; } // GET: api/product/1 [HttpGet(\"{id}\")] public ActionResult\u003cstring\u003e GetById(int id) { if (id \u003c 0 || id \u003e= products.Count) return NotFound(\"Product not found\"); return products[id]; } // POST: api/product [HttpPost] public ActionResult AddProduct([FromBody] string product) { products.Add(product); return Ok(\"Product added\"); } } } "},"title":"Controllers"},"/docs/asp.net-core/mockinghttpclient/":{"data":{"":"","#":"There would surely be scenarios in your application where you should use a HTTP Client to request for resources from another server. But how can you mock the behaviour of the default methods of the Http Client provided by the .NET Core Framework while writing unit tests? This post is meant to mock such HTTP request handling for unit testing.\nConsider the following code where a service named SocialMediaPostsService uses a HTTP Client to request json objects from Dummy JSON.\nSocialMediaPostsService.cspublic class SocialMediaPostsService(IHttpClientFactory httpClientFactory) : ISocialMediaPostsService { private const string BaseUrl = \"https://dummyjson.com\"; private readonly HttpClient _httpClient = httpClientFactory.CreateClient( Constants.DUMMY_JSON_CLIENT ); public async Task\u003cIEnumerable\u003cstring\u003e?\u003e GetAllTagsForPostAsync( int postId, CancellationToken cancellationToken ) { var response = await _httpClient.GetAsync($\"{BaseUrl}/posts\", cancellationToken); response.EnsureSuccessStatusCode(); var posts = await response.Content.ReadFromJsonAsync\u003cPostsResponse\u003e( ObjectSerializer.GetOptions, cancellationToken ); return posts!.Posts.FirstOrDefault(x =\u003e x.Id == postId)?.Tags; } public async Task\u003cPost\u003e AddPostAsync( Post post, CancellationToken cancellationToken ) { var response = await _httpClient.PostAsJsonAsync( $\"{BaseUrl}/posts/add\", post, ObjectSerializer.GetOptions, cancellationToken ); response.EnsureSuccessStatusCode(); return await response.Content.ReadFromJsonAsync\u003cPost\u003e( ObjectSerializer.GetOptions, cancellationToken ) ?? throw new InvalidOperationException(\"Failed to deserialize the post.\"); } } Note\nUsing IHttpClientFactory ensures efficient connection management and allows pre-configured named clients for consistent setup and reuse.\nShown below is the ISocialMediaPostsService interface used for dependency injection.\nISocialMediaPostsService.cspublic interface ISocialMediaPostsService { Task\u003cIEnumerable\u003cstring\u003e?\u003e GetAllTagsForPostAsync( int postId, CancellationToken cancellationToken ); Task\u003cPost\u003e AddPostAsync( Post post, CancellationToken cancellationToken ); } To be able to understand how the client can be mocked, it is essential to understand how the client handles the HTTP request message.\nIn Brief HttpClient inherits from HttpMessageInvoker The HttpClient class is built on top of HttpMessageInvoker, which is responsible for forwarding HTTP requests.\nIf you carefully look at the source code for HttpClient, you will notice that the class inherits from HttpMessageInvoker. Our Http Client’s GetAsync method internally invokes a base method in HttpMessageInvoker namely:\nHttpMessageInvoker.cspublic virtual Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) HttpMessageInvoker holds a reference to HttpMessageHandler When an HTTP request is made, HttpMessageInvoker uses the internal HttpMessageHandler provided to handle the HTTP request.\nThe request is passed to HttpMessageHandler The handler processes the request. This is the main point where the actual HTTP logic is handled. The following is the core method for handling.\nHttpMessageHandler.csprotected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken) { throw new NotSupportedException(SR.Format(SR.net_http_missing_sync_implementation, GetType(), nameof(HttpMessageHandler), nameof(Send))); } Custom handlers can override this behavior The HttpMessageHandler class provides the following abstract method to be overriden by an extending class to implement a custom handling of HttpRequestMessage.\nHttpMessageHandler.csprotected internal abstract Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken); By extending HttpMessageHandler, we can intercept requests and return controlled responses, which is how mocking works in tests.\nOur MockHttpMessageHandler would look like this MockHttpMessageHandler.cspublic class MockHttpMessageHandler : HttpMessageHandler { protected override Task\u003cHttpResponseMessage\u003e SendAsync( HttpRequestMessage request, CancellationToken cancellationToken ) { return Task.FromResult(MockSendAsync(request, cancellationToken)); } public virtual HttpResponseMessage MockSend( HttpRequestMessage request, CancellationToken cancellationToken ) { throw new NotImplementedException(); } } In the above HTTP mock handler we can create our own method MockSend to be overwritten when we like to write a test, but for the moment we just throw a NotImplementedException. We can then override the abstract method provided by HttpMessageHandler to return the result of our own method MockSend. This is how we can make sure than when the HttpMessageHandler's SendAsyncmethod is invoked by the framework, our method MockSend is invoked internally.\nMockHttpMessageHandlerTestBase class for reusable testing For the ease of writing tests for classes that uses a HttpClient, we can create a resuable class to handle everything related to our HTTP mock handler, like making our handler return a specific object and a staus code, ensure that the mock handler had received a HTTP request message with a particular Ùri,HttpMethod and Content. The test class uses the follwoing library:\nxUnit NSubstitue Shouldly AutoBogus MockHttpMessageHandlerTestBasecspublic class MockHttpMessageHandlerTestBase { protected MockHttpMessageHandlerTestBase() { var httpClient = new HttpClient(HttpMessageHandlerMock) { BaseAddress = new Uri(\"http://localhost:5000\") }; HttpClientFactory.CreateClient(Arg.Any\u003cstring\u003e()).Returns(httpClient); } private MockHttpMessageHandler HttpMessageHandlerMock { get; } = Substitute.ForPartsOf\u003cMockHttpMessageHandler\u003e(); protected IHttpClientFactory HttpClientFactory { get; } = Substitute.For\u003cIHttpClientFactory\u003e(); /// \u003csummary\u003e /// Verifies that the mocked HTTP message handler processes a request with the specified HTTP method /// and a request URI containing the given string. /// \u003c/summary\u003e /// \u003cparam name=\"httpMethod\"\u003eThe HTTP method (e.g., GET, POST) to validate against the request.\u003c/param\u003e /// \u003cparam name=\"requestUri\"\u003eThe string that should be contained in the request URI.\u003c/param\u003e protected void HttpMockHandlerShouldHandleFor(HttpMethod httpMethod, string requestUri) { HttpMockHandlerDoes(message =\u003e { message.Method.ShouldBe(httpMethod); message.RequestUri!.AbsoluteUri.ShouldContain(requestUri); }); } /// \u003csummary\u003e /// Configures the mocked HTTP message handler to return a response with the specified content and status code /// when any HTTP request is sent. /// \u003c/summary\u003e /// \u003ctypeparam name=\"TResponse\"\u003eThe type of the response content to be serialized as JSON.\u003c/typeparam\u003e /// \u003cparam name=\"response\"\u003eThe response object to be serialized and returned in the HTTP response body.\u003c/param\u003e /// \u003cparam name=\"statusCode\"\u003eThe HTTP status code to be set in the response.\u003c/param\u003e protected void HttpMockHandlerReturns\u003cTResponse\u003e(TResponse response, HttpStatusCode statusCode) { HttpMessageHandlerMock .MockSend(Arg.Any\u003cHttpRequestMessage\u003e(), Arg.Any\u003cCancellationToken\u003e()) .Returns(x =\u003e new HttpResponseMessage(statusCode) { Content = JsonContent.Create(response) }); } /// \u003csummary\u003e /// Verifies that the mocked HTTP message handler receives a request with a JSON body /// matching the specified request object. /// \u003c/summary\u003e /// \u003ctypeparam name=\"TRequest\"\u003eThe type of the request object expected in the HTTP request body.\u003c/typeparam\u003e /// \u003cparam name=\"requestObject\"\u003eThe expected request object to compare against the deserialized request body.\u003c/param\u003e protected void HttpMockHandlerShouldReceiveObject\u003cTRequest\u003e(TRequest requestObject) { HttpMockHandlerDoes(message =\u003e { Debug.Assert(message.Content != null); var content = message.Content.ReadAsStringAsync().Result; var receivedObject = JsonSerializer.Deserialize\u003cTRequest\u003e(content); receivedObject.ShouldBe(requestObject); }); } private void HttpMockHandlerDoes(Action\u003cHttpRequestMessage\u003e callbackAction) { HttpMessageHandlerMock .When(x =\u003e x.MockSend(Arg.Any\u003cHttpRequestMessage\u003e(), Arg.Any\u003cCancellationToken\u003e())) .Do(x =\u003e callbackAction(x.Arg\u003cHttpRequestMessage\u003e())); } } Note\nNote how we create a HttpClient with our custom handler HttpMessageHandlerMock as the request message handler and carefully mock the CreateClient of the IHttpClientFactory to return the HttpClient.\nWarning\nThe above MockHttpMessageHandlerTestBase can be used as test base class if you use the interface ÌHttpClientFactory to create the HttpClient. Otherwise you need to modify the base class.\nWriting unit tests with MockHttpMessageHandlerTestBase SocialMediaPostsServiceTests.cspublic class SocialMediaPostsServiceTests : MockHttpMessageHandlerTestBase { private readonly ISocialMediaPostsService _socialMediaPostsServiceMock; public SocialMediaPostsServiceTests() { _socialMediaPostsServiceMock = new SocialMediaPostsService(HttpClientFactory); } [Theory] [InlineData(1)] [InlineData(2)] public async Task GetAllTagsForPostTestAsync(int postId) { var posts = GetAllPosts(); HttpMockHandlerReturns(posts, HttpStatusCode.OK); HttpMockHandlerShouldHandleFor(HttpMethod.Get, \"dummyjson.com/posts\"); var tags = await _socialMediaPostsServiceMock.GetAllTagsForPostAsync( postId, CancellationToken.None ); tags.ShouldBeEquivalentTo(posts.Posts.Find(x =\u003e x.Id == postId)?.Tags); } [Fact] public async Task AddPostTestAsync() { var postToSend = new AutoFaker\u003cPost\u003e().UseSeed(42).Generate(); var postReceived = new AutoFaker\u003cPost\u003e().UseSeed(42).Generate(); HttpMockHandlerReturns(postReceived, HttpStatusCode.OK); HttpMockHandlerShouldHandleFor(HttpMethod.Post, \"dummyjson.com/posts/add\"); var post = await _socialMediaPostsServiceMock.AddPostAsync( postToSend, CancellationToken.None ); post.ShouldNotBeNull(); post.ShouldBeEquivalentTo(postReceived); HttpMockHandlerShouldReceiveObject(postToSend); } private static PostsResponse GetAllPosts() { return new PostsResponse { Posts = [ new Post { Id = 1, Tags = new List\u003cstring\u003e { \"tag1\", \"tag2\", \"tag3\", \"tag4\" } }, new Post { Id = 2, Tags = new List\u003cstring\u003e { \"tag5\", \"tag6\" } } ], Total = 2, Skip = 0, Limit = 10 }; } } In this test, we inject a mock IHttpClientFactory into the service. The factory returns a HttpClient that uses our custom MockHttpMessageHandler. This lets us simulate HTTP responses and verify requests without making real network calls. The service uses this client just like it would in production, but everything is controlled in the test.\nYou can find the codes in the following GitHub repository.\nMocking-Request-Handling-by-HTTP-Client "},"title":"Mocking Request Handling by HTTP Client"}}